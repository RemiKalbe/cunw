<directory_tree>
/
├── /
│   └── .github/
│       └── workflows/
│           ├── publish.yaml
│           └── tests.yaml
├── .gitignore
├── CHANGELOG.md
├── Cargo.toml
├── LICENSE
├── README.md
├── output.md
└── src/
    ├── args.rs
    ├── codebase.rs
    ├── gitignore.rs
    ├── logger.rs
    ├── main.rs
    └── os.rs

</directory_tree>

<file path=./.github/workflows/publish.yaml>
name: Publish to crate.io

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install GitHub CLI
        run: |
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh
      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          cargo login ${CARGO_REGISTRY_TOKEN}
          cargo publish
      - name: Create Git Tag
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git tag -a v${{ inputs.version }} -m "Release ${{ inputs.version }}"
          git push origin v${{ inputs.version }}
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create v${{ inputs.version }} \
            --title "Release ${{ inputs.version }}" \
            --generate-notes

</file>
<file path=./.github/workflows/tests.yaml>
name: Continuous tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    name: Test on ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Build
        run: cargo build --verbose
      - name: Run tests
        run: cargo test --verbose

  is-unpublished:
    runs-on: ubuntu-latest
    name: Is this version unpublished?
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Install toml
        run: cargo install toml-cli
      - name: Extract version from Cargo.toml
        id: extract_version
        run: |
          VERSION=$(toml get Cargo.toml package.version | tr -d '"')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=${VERSION}" >> $GITHUB_ENV
      - name: Extract crate name from Cargo.toml
        id: extract_crate_name
        run: echo "PACKAGE_NAME=$(toml get Cargo.toml package.name | tr -d '"')" >> $GITHUB_ENV
      - name: Get latest published version
        id: latest_version
        run: echo "LATEST_VERSION=$(cargo search ${{ env.PACKAGE_NAME }} --limit 1 | grep -oP '(?<=").*(?=")' | head -1)" >> $GITHUB_ENV
      - name: Compare versions
        run: |
          if [ "$(printf '%s\n' "${{ env.LATEST_VERSION }}" "${{ env.PACKAGE_VERSION }}" | sort -V | tail -n1)" = "${{ env.PACKAGE_VERSION }}" ] && [ "${{ env.PACKAGE_VERSION }}" != "${{ env.LATEST_VERSION }}" ]; then
            echo "Local version (${{ env.PACKAGE_VERSION }}) is newer than the latest published version (${{ env.LATEST_VERSION }})"
            echo "should_publish=true" >> $GITHUB_OUTPUT
          else
            echo "Local version (${{ env.PACKAGE_VERSION }}) is not newer than the latest published version (${{ env.LATEST_VERSION }})"
            echo "should_publish=false" >> $GITHUB_OUTPUT
          fi

  call-publish:
    needs: [test, is-unpublished]
    if: >
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.is-unpublished.outputs.should_publish == 'true' &&
      startsWith(github.ref, 'refs/tags/v')
    uses: ./.github/workflows/publish.yaml
    with:
      version: ${{ needs.is-unpublished.outputs.version }}
    secrets: inherit

</file>
<file path=./.gitignore>
/target

</file>
<file path=./CHANGELOG.md>
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.1] - 2024-05-13

### Fixed

- The `path` property in the generated file is now correctly formatted inside double quotes.

## [0.2.0] - 2024-05-13

### Added

- Introduced a new `CodebaseBuilder` struct to facilitate the construction of the codebase representation.
- Implemented a `GitIgnore` struct to handle parsing and matching of `.gitignore` patterns.
- Introduced a new `FileContent` struct to handle asynchronous file content loading.
- Added crate `nuclei` for asynchronous file reading. (Need to evaluate if it's a good fit)
- Added a `CodebaseItem` enum to represent files and directories in the codebase.
- Implemented a `Codebase` struct to hold the codebase tree and provide formatting methods.
- Introduced an `os` module for platform-specific utilities.

### Changed

- Refactored the codebase traversal logic to use the `CodebaseBuilder` struct.
  The main improvement of this refactoring is the fact that the codebase is only traversed once, simultaneously filtering, collecting, and building the codebase representation.
- Improved error handling and reporting using the `miette` crate.
- Improved logs formatting and verbosity levels.
- Refactored the output file generation to use the `Codebase` struct and its formatting methods.

### Removed

- Removed the `walk` module and integrated its functionality into the `CodebaseBuilder`.
- Removed the `file` module and integrated its functionality into the `codebase` module.
- Removed the `errors` module and replaced it with the `miette` crate for error handling.
- Removed the crate `ptree` and replaced it with `termtree` for tree formatting.
- Removed the crate `ignore-files` and implemented custom logic for `.gitignore` parsing.
- Removed the crate `crossterm` as it was overkill, replaced with `colored`.

### Fixed

- Fixed various issues and improved code quality throughout the codebase.
- Improved overall performance.

## [0.1.0] - 2024-05-11

### Added

- Initial release of cunw
- Recursive directory traversal and file content collection
- Markdown generation representing codebase structure and content
- Support for excluding and including files based on glob patterns
- Respect for `.gitignore` files (can be disabled)
- Option to specify maximum depth of directory traversal
- Option to follow symbolic links (disabled by default)
- Verbose output for debugging purposes

### Fixed

- Minor improvements to error handling and logging

[Unreleased]: https://github.com/RemiKalbe/cunw/compare/v0.2.0...HEAD
[0.2.0]: https://github.com/RemiKalbe/cunw/releases/tag/v0.2.0
[0.1.0]: https://github.com/RemiKalbe/cunw/releases/tag/v0.1.0

</file>
<file path=./Cargo.toml>
[package]
name = "cunw"
description = "A tiny utility that generates a file representing the structure and content of a directory. Made to easily give context to a LLM."
license-file = "MIT"
repository = "https://github.com/RemiKalbe/cunw"
homepage = "https://github.com/RemiKalbe/cunw"
readme = "README.md"
keywords = ["code", "prompt", "directory", "context", "llm"]
categories = ["command-line-utilities", "filesystem"]
version = "0.2.1"
edition = "2021"

[dependencies]
arc-swap = "1.7.1"
clap = { version = "=4.5.3", features = ["derive", "unicode", "wrap_help"] }
clap-verbosity-flag = "2.2.0"
colored = "2.1.0"
env_logger = "0.11.3"
file-format = "0.25.0"
futures = "0.3.30"
globset = "0.4.14"
indicatif = { version = "0.17.8", features = ["improved_unicode"] }
log = "0.4.21"
miette = { version = "7.2.0", features = ["fancy"] }
nuclei = "0.4.4"
rstest = "0.19.0"
tempfile = "3.10.1"
termbg = "0.5.0"
terminal-emoji = "0.4.1"
termtree = "0.4.1"
tokio = { version = "1.37.0", features = ["sync"] }
walkdir = "2.5.0"

</file>
<file path=./LICENSE>
Copyright 2024 Rémi Kalbe

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

</file>
<file path=./README.md>
# cunw

cunw (codebase unwrap) is a command-line interface (CLI) tool that generates a structured representation of a codebase, making it easy to provide context to a large language model (LLM). It recursively traverses a directory, collects file content, and generates a single Markdown file that represents the structure and content of the codebase.

> [!WARNING]
> Please note that cunw is currently in a very early and experimental stage. It has not been extensively tested and may be prone to crashes or unexpected behavior. However, rest assured that any crashes will be limited to the tool itself and will not cause any harm to your system or files.

## 🌟 Features

- Recursively traverses a directory and collects file content
- Generates a Markdown file representing the codebase structure and content
- Supports excluding files based on glob patterns
- Respects `.gitignore` files by default (can be disabled)
- Allows specifying the maximum depth of directory traversal
- Supports following symbolic links (disabled by default)

## 📦 Installation

### Precompiled Binaries

You can easily install cunw through cargo:

```bash
cargo install cunw
```

Or download the precompiled binaries from the [releases page](https://github.com/RemiKalbe/cunw/releases).

### From Source

To install cunw, ensure you have Rust and Cargo installed on your system. Then, clone the repository and build the project:

```bash
git clone https://github.com/RemiKalbe/cunw.git
cd cunw
cargo build --release
```

The compiled binary will be available at `target/release/cunw`.

## 🚀 Usage

```bash
cunw [OPTIONS]
```

### Options

- `-p, --path <PATH>`: The path to the directory containing the codebase.
- `-o, --output <FILE>`: The path of the output file. Default: `output.txt`
- `-e, --exclude <PATTERN>`: Exclude files or directories matching the specified glob pattern.
- `--do-not-consider-ignore-files`: Do not consider `.gitignore` files when filtering. Default: `false`
- `--dangerously-allow-dot-git-traversal`: Include `.git` directory in the search. Default: `false`
- `-d, --max-depth <DEPTH>`: Maximum depth to walk into the directory tree.
- `-f, --follow-symbolic-links`: Follow symbolic links. Default: `false`
- `-v, --verbose`: Set the verbosity level. Can be used multiple times to increase verbosity.

### Example

To generate a Markdown representation of a codebase located at `path/to/codebase`, excluding files matching `*.txt` and save the output to `codebase.md`:

```bash
cunw path/to/codebase -o codebase.md -e "*.txt"
```

## 📝 Output Format

The generated Markdown file will have the following structure:

```markdown
<directory_structure>
.
└─ .
├─ ./src
│ ├─ main.rs
│ └─ lib.rs
├─ .gitignore
├─ Cargo.lock
└─ Cargo.toml
</directory_structure>

<file path="Cargo.toml">
[package]
name = "cunw"
version = "0.1.0"
edition = "2021"

[dependencies]

<!-- ... -->
</file>

<file path="src/main.rs">
fn main() {
    println!("Hello, world!");
}
</file>

<!-- ... -->
```

The `<directory_structure>` section represents the directory tree of the codebase, and each `<file>` section contains the content of a specific file.

## 🤝 Contributing

Contributions are welcome! If you find any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.

## 📄 License

This project is licensed under the [MIT License](LICENSE).

</file>
<file path=./output.md>
<directory_tree>
/
├── /
│   └── .github/
│       └── workflows/
│           ├── publish.yaml
│           └── tests.yaml
├── .gitignore
├── CHANGELOG.md
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README.md
└── src/
    ├── args.rs
    ├── codebase.rs
    ├── gitignore.rs
    ├── logger.rs
    ├── main.rs
    └── os.rs

</directory_tree>

<file path=./.github/workflows/publish.yaml>
name: Publish to crate.io

on:
  workflow_call:
    tags:
      - "v*"

jobs:
  publish:
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          cargo login ${CARGO_REGISTRY_TOKEN}
          cargo publish

</file>
<file path=./.github/workflows/tests.yaml>
name: Continuous tests

on:
  push:
    branches: [main]
    tags:
      - "v*"
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    name: Test on ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Build
        run: cargo build --verbose
      - name: Run tests
        run: cargo test --verbose

  call-publish:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: test
    uses: ./.github/workflows/publish.yaml

</file>
<file path=./.gitignore>
/target

</file>
<file path=./CHANGELOG.md>
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.0] - 2024-05-11

### Added

- Initial release of cunw
- Recursive directory traversal and file content collection
- Markdown generation representing codebase structure and content
- Support for excluding and including files based on glob patterns
- Respect for `.gitignore` files (can be disabled)
- Option to specify maximum depth of directory traversal
- Option to follow symbolic links (disabled by default)
- Verbose output for debugging purposes

### Fixed

- Minor improvements to error handling and logging

[Unreleased]: https://github.com/yourusername/cunw/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/yourusername/cunw/releases/tag/v0.1.0

</file>
<file path=./Cargo.lock>
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
dependencies = [
 "cfg-if",
 "getrandom",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "ansi-colors-macro"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4c2afa84a2916e88ff06df6fd84e7c89e374a726e392f72dc5e32d6db3c3cf6"

[[package]]
name = "anstream"
version = "0.6.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "418c75fa768af9c03be99d17643f93f79bbba589895012a80e3452a19ddda15b"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "038dfcf04a5feb68e9c60b21c9625a54c2c0616e79b72b0fd87075a056ae1d1b"

[[package]]
name = "anstyle-parse"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c03a11a9034d92058ceb6ee011ce58af4a9bf61491aa7e1e59ecd24bd40d22d4"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a64c907d4e79225ac72e2a354c9ce84d50ebb4586dee56c82b3ee73004f537f5"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61a38449feb7068f52bb06c12759005cf459ee52bb4adc1d5a7c4322d716fb19"
dependencies = [
 "anstyle",
 "windows-sys 0.52.0",
]

[[package]]
name = "anyhow"
version = "1.0.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25bdb32cbbdce2b519a9cd7df3a678443100e265d5e25ca763b7572a5104f5f3"

[[package]]
name = "arc-swap"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"

[[package]]
name = "async-channel"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81953c529336010edd6d8e358f886d9581267795c61b19475b71314bffa46d35"
dependencies = [
 "concurrent-queue",
 "event-listener 2.5.3",
 "futures-core",
]

[[package]]
name = "async-channel"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "136d4d23bcc79e27423727b36823d86233aad06dfea531837b038394d11e9928"
dependencies = [
 "concurrent-queue",
 "event-listener 5.3.0",
 "event-listener-strategy 0.5.2",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-executor"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b10202063978b3351199d68f8b22c4e47e4b1b822f8d43fd862d5ea8c006b29a"
dependencies = [
 "async-task",
 "concurrent-queue",
 "fastrand 2.1.0",
 "futures-lite 2.3.0",
 "slab",
]

[[package]]
name = "async-global-executor"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05b1b633a2115cd122d73b955eadd9916c18c8f510ec9cd1686404c60ad1c29c"
dependencies = [
 "async-channel 2.2.1",
 "async-executor",
 "async-io 2.3.2",
 "async-lock 3.3.0",
 "blocking",
 "futures-lite 2.3.0",
 "once_cell",
]

[[package]]
name = "async-io"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fc5b45d93ef0529756f812ca52e44c221b35341892d3dcc34132ac02f3dd2af"
dependencies = [
 "async-lock 2.8.0",
 "autocfg",
 "cfg-if",
 "concurrent-queue",
 "futures-lite 1.13.0",
 "log",
 "parking",
 "polling 2.8.0",
 "rustix 0.37.27",
 "slab",
 "socket2 0.4.10",
 "waker-fn",
]

[[package]]
name = "async-io"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcccb0f599cfa2f8ace422d3555572f47424da5648a4382a9dd0310ff8210884"
dependencies = [
 "async-lock 3.3.0",
 "cfg-if",
 "concurrent-queue",
 "futures-io",
 "futures-lite 2.3.0",
 "parking",
 "polling 3.7.0",
 "rustix 0.38.34",
 "slab",
 "tracing",
 "windows-sys 0.52.0",
]

[[package]]
name = "async-lock"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "287272293e9d8c41773cec55e365490fe034813a2f172f502d6ddcf75b2f582b"
dependencies = [
 "event-listener 2.5.3",
]

[[package]]
name = "async-lock"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d034b430882f8381900d3fe6f0aaa3ad94f2cb4ac519b429692a1bc2dda4ae7b"
dependencies = [
 "event-listener 4.0.3",
 "event-listener-strategy 0.4.0",
 "pin-project-lite",
]

[[package]]
name = "async-std"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62565bb4402e926b29953c785397c6dc0391b7b446e45008b0049eb43cec6f5d"
dependencies = [
 "async-channel 1.9.0",
 "async-global-executor",
 "async-io 1.13.0",
 "async-lock 2.8.0",
 "crossbeam-utils",
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-lite 1.13.0",
 "gloo-timers",
 "kv-log-macro",
 "log",
 "memchr",
 "once_cell",
 "pin-project-lite",
 "pin-utils",
 "slab",
 "wasm-bindgen-futures",
]

[[package]]
name = "async-task"
version = "4.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b75356056920673b02621b35afd0f7dda9306d03c79a30f5c56c44cf256e3de"

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "atty"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
dependencies = [
 "hermit-abi 0.1.19",
 "libc",
 "winapi",
]

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.71"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26b05800d2e817c8b3b4b54abd461726265fa9789ae34330622f2db9ee696f9d"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "backtrace-ext"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "537beee3be4a18fb023b570f80e3ae28003db9167a751266b259926e25539d50"
dependencies = [
 "backtrace",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf4b9d6a944f767f8e5e0db018570623c85f3d925ac718db4e06d0187adb21c1"

[[package]]
name = "blocking"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "495f7104e962b7356f0aeb34247aca1fe7d2e783b346582db7f2904cb5717e88"
dependencies = [
 "async-channel 2.2.1",
 "async-lock 3.3.0",
 "async-task",
 "futures-io",
 "futures-lite 2.3.0",
 "piper",
]

[[package]]
name = "bstr"
version = "1.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05efc5cfd9110c8416e471df0e96702d58690178e206e61b7173706673c93706"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "cc"
version = "1.0.97"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "099a5357d84c4c61eb35fc8eafa9a79a902c2f76911e5747ced4e032edd8d9b4"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "clap"
version = "4.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "949626d00e063efc93b6dca932419ceb5432f99769911c0b995f7e884c778813"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap-verbosity-flag"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb9b20c0dd58e4c2e991c8d203bbeb76c11304d1011659686b5b644bc29aa478"
dependencies = [
 "clap",
 "log",
]

[[package]]
name = "clap_builder"
version = "4.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae129e2e766ae0ec03484e609954119f123cc1fe650337e155d03b022f24f7b4"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
 "terminal_size",
 "unicase",
 "unicode-width",
]

[[package]]
name = "clap_derive"
version = "4.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90239a040c80f5e14809ca132ddc4176ab33d5e17e49691793296e3fcb34d72f"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.61",
]

[[package]]
name = "clap_lex"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98cc8fbded0c607b7ba9dd60cd98df59af97e84d24e49c8557331cfc26d301ce"

[[package]]
name = "colorchoice"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b6a852b24ab71dffc585bcb46eaf7959d175cb865a7152e35b348d1b2960422"

[[package]]
name = "colored"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbf2150cce219b664a8a70df7a1f933836724b503f8a413af9365b4dcc4d90b8"
dependencies = [
 "lazy_static",
 "windows-sys 0.48.0",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "console"
version = "0.15.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e1f83fc076bd6dd27517eacdf25fef6c4dfe5f1d7448bafaaf3a26f13b5e4eb"
dependencies = [
 "encode_unicode",
 "lazy_static",
 "libc",
 "unicode-width",
 "windows-sys 0.52.0",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab3db02a9c5b5121e1e42fbdb1aeb65f5e02624cc58c43f2884c6ccac0b82f95"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "248e3bacc7dc6baa3b21e405ee045c3047101a49145e7e9eca583ab4c2ca5345"

[[package]]
name = "crossterm"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f476fe445d41c9e991fd07515a6f463074b782242ccf4a5b7b1d1012e70824df"
dependencies = [
 "bitflags 2.5.0",
 "crossterm_winapi",
 "libc",
 "mio",
 "parking_lot 0.12.2",
 "signal-hook",
 "signal-hook-mio",
 "winapi",
]

[[package]]
name = "crossterm_winapi"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "acdd7c62a3665c7f6830a51635d9ac9b23ed385797f70a83bb8bafe9c572ab2b"
dependencies = [
 "winapi",
]

[[package]]
name = "cunw"
version = "0.1.0"
dependencies = [
 "arc-swap",
 "clap",
 "clap-verbosity-flag",
 "colored",
 "env_logger",
 "file-format",
 "futures",
 "globset",
 "indicatif",
 "log",
 "miette",
 "nuclei",
 "rstest",
 "tempfile",
 "termbg",
 "terminal-emoji",
 "terminal-log-symbols",
 "termtree",
 "thiserror",
 "tokio",
 "walkdir",
]

[[package]]
name = "either"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47c1c47d2f5964e29c61246e81db715514cd532db6b5116a25ea3c03d6780a2"

[[package]]
name = "encode_unicode"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f"

[[package]]
name = "env_filter"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a009aa4810eb158359dda09d0c87378e4bbb89b5a801f016885a4707ba24f7ea"
dependencies = [
 "log",
 "regex",
]

[[package]]
name = "env_logger"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38b35839ba51819680ba087cd351788c9a3c476841207e0b8cee0b04722343b9"
dependencies = [
 "anstream",
 "anstyle",
 "env_filter",
 "humantime",
 "log",
]

[[package]]
name = "errno"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "event-listener"
version = "2.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"

[[package]]
name = "event-listener"
version = "4.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b215c49b2b248c855fb73579eb1f4f26c38ffdc12973e20e07b91d78d5646e"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d9944b8ca13534cdfb2800775f8dd4902ff3fc75a50101466decadfdf322a24"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "958e4d70b6d5e81971bebec42271ec641e7ff4e170a6fa605f2b8a8b65cb97d3"
dependencies = [
 "event-listener 4.0.3",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f214dc438f977e6d4e3500aaa277f5ad94ca83fbbd9b1a15713ce2344ccc5a1"
dependencies = [
 "event-listener 5.3.0",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
dependencies = [
 "instant",
]

[[package]]
name = "fastrand"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"

[[package]]
name = "file-format"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ffe3a660c3a1b10e96f304a9413d673b2118d62e4520f7ddf4a4faccfe8b9b9"

[[package]]
name = "futures"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645c6916888f6cb6350d2550b80fb63e734897a8498abe35cfb732b6487804b0"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac8f7d7865dcb88bd4373ab671c8cf4508703796caa2b1985a9ca867b3fcb78"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"

[[package]]
name = "futures-executor"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a44623e20b9681a318efdd71c299b6b222ed6f231972bfe2f224ebad6311f0c1"

[[package]]
name = "futures-lite"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49a9d51ce47660b1e808d3c990b4709f2f415d928835a17dfd16991515c46bce"
dependencies = [
 "fastrand 1.9.0",
 "futures-core",
 "futures-io",
 "memchr",
 "parking",
 "pin-project-lite",
 "waker-fn",
]

[[package]]
name = "futures-lite"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52527eb5074e35e9339c6b4e8d12600c7128b68fb25dcb9fa9dec18f7c25f3a5"
dependencies = [
 "fastrand 2.1.0",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "futures-macro"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.61",
]

[[package]]
name = "futures-sink"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fb8e00e87438d937621c1c6269e53f536c14d3fbd6a042bb24879e57d474fb5"

[[package]]
name = "futures-task"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"

[[package]]
name = "futures-timer"
version = "3.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f288b0a4f20f9a56b5d1da57e2227c661b7b16168e2f72365f57b63326e29b24"

[[package]]
name = "futures-util"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.28.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253"

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "globset"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57da3b9b5b85bd66f31093f8c408b90a74431672542466497dcbdfdc02034be1"
dependencies = [
 "aho-corasick",
 "bstr",
 "log",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "gloo-timers"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b995a66bb87bebce9a0f4a95aed01daca4872c050bfcb21653361c03bc35e5c"
dependencies = [
 "futures-channel",
 "futures-core",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
dependencies = [
 "libc",
]

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "indicatif"
version = "0.17.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "763a5a8f45087d6bcea4222e7b72c291a054edf80e4ef6efd2a4979878c7bea3"
dependencies = [
 "console",
 "instant",
 "number_prefix",
 "portable-atomic",
 "unicode-segmentation",
 "unicode-width",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
]

[[package]]
name = "io-lifetimes"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eae7b9aee968036d54dce06cebaefd919e4472e753296daccd6d344e3e2df0c2"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "windows-sys 0.48.0",
]

[[package]]
name = "is-terminal"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f23ff5ef2b80d608d61efee834934d862cd92461afc0560dedf493e4c033738b"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "is_ci"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7655c9839580ee829dfacba1d1278c2b7883e50a277ff7541299489d6bdfdc45"

[[package]]
name = "is_terminal_polyfill"
version = "1.70.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8478577c03552c21db0e2724ffb8986a5ce7af88107e6be5d2ee6e158c12800"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "js-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29c15563dc2726973df627357ce0c9ddddbea194836909d655df6a75d2cf296d"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "kv-log-macro"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0de8b303297635ad57c9f5059fd9cee7a47f8e8daa09df0fcd07dd39fb22977f"
dependencies = [
 "log",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "lever"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5823897ba55199b5300dbf5551027f66802c9dcf2f3a0b4f8c46d750124f57f2"
dependencies = [
 "anyhow",
 "crossbeam-epoch",
 "itertools",
 "lazy_static",
 "log",
 "parking_lot 0.11.2",
 "slice-group-by",
 "thiserror",
]

[[package]]
name = "libc"
version = "0.2.154"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae743338b92ff9146ce83992f766a31066a91a8c84a45e0e9f21e7cf6de6d346"

[[package]]
name = "linux-raw-sys"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"

[[package]]
name = "linux-raw-sys"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01cda141df6706de531b6c46c3a33ecca755538219bd484262fa09410c13539c"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90ed8c1e510134f979dbc4f070f87d4313098b704861a105fe34231c70a3901c"
dependencies = [
 "value-bag",
]

[[package]]
name = "memchr"
version = "2.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8640c5d730cb13ebd907d8d04b52f55ac9a2eec55b440c8892f40d56c76c1d"

[[package]]
name = "miette"
version = "7.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4edc8853320c2a0dab800fbda86253c8938f6ea88510dc92c5f1ed20e794afc1"
dependencies = [
 "backtrace",
 "backtrace-ext",
 "cfg-if",
 "miette-derive",
 "owo-colors",
 "supports-color",
 "supports-hyperlinks",
 "supports-unicode",
 "terminal_size",
 "textwrap",
 "thiserror",
 "unicode-width",
]

[[package]]
name = "miette-derive"
version = "7.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcf09caffaac8068c346b6df2a7fc27a177fd20b39421a39ce0a211bde679a6c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.61",
]

[[package]]
name = "miniz_oxide"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d811f3e15f28568be3407c8e7fdb6514c1cda3cb30683f15b6a1a1dc4ea14a7"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "nuclei"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "708cc2eaca5debf2652cd0de66e16e1a9587ed63af886c04d82a0bce054a532d"
dependencies = [
 "ahash",
 "async-global-executor",
 "crossbeam-channel",
 "futures",
 "lever",
 "libc",
 "nuclei-attributes",
 "once_cell",
 "os_socketaddr",
 "pin-project-lite",
 "pin-utils",
 "rustix 0.38.34",
 "rustix-uring",
 "socket2 0.3.19",
]

[[package]]
name = "nuclei-attributes"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86301c1ea5b0ddf9ccf79de4d15c17d53e5b7923f681de990650704f28bc27d1"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "number_prefix"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3"

[[package]]
name = "object"
version = "0.32.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "os_socketaddr"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa149f3ec09cadeb41968390fcd71e6ea038a9a373d1d4eb070f4d9484d4b244"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "owo-colors"
version = "4.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caff54706df99d2a78a5a4e3455ff45448d81ef1bb63c22cd14052ca0e993a3f"

[[package]]
name = "parking"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb813b8af86854136c6922af0598d719255ecb2179515e6e7730d468f05c9cae"

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core 0.8.6",
]

[[package]]
name = "parking_lot"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e4af0ca4f6caed20e900d564c242b8e5d4903fdacf31d3daf527b66fe6f42fb"
dependencies = [
 "lock_api",
 "parking_lot_core 0.9.10",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall 0.2.16",
 "smallvec",
 "winapi",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.1",
 "smallvec",
 "windows-targets 0.52.5",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "piper"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "668d31b1c4eba19242f2088b2bf3316b82ca31082a8335764db4e083db7485d4"
dependencies = [
 "atomic-waker",
 "fastrand 2.1.0",
 "futures-io",
]

[[package]]
name = "polling"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b2d323e8ca7996b3e23126511a523f7e62924d93ecd5ae73b333815b0eb3dce"
dependencies = [
 "autocfg",
 "bitflags 1.3.2",
 "cfg-if",
 "concurrent-queue",
 "libc",
 "log",
 "pin-project-lite",
 "windows-sys 0.48.0",
]

[[package]]
name = "polling"
version = "3.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645493cf344456ef24219d02a768cf1fb92ddf8c92161679ae3d91b91a637be3"
dependencies = [
 "cfg-if",
 "concurrent-queue",
 "hermit-abi 0.3.9",
 "pin-project-lite",
 "rustix 0.38.34",
 "tracing",
 "windows-sys 0.52.0",
]

[[package]]
name = "portable-atomic"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7170ef9988bc169ba16dd36a7fa041e5c4cbeb6a35b76d4c03daded371eae7c0"

[[package]]
name = "proc-macro2"
version = "1.0.82"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ad3d49ab951a01fbaafe34f2ec74122942fe18a3f9814c3268f1bb72042131b"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469052894dcb553421e483e4209ee581a45100d31b4018de03e5a7ad86374a7e"
dependencies = [
 "bitflags 2.5.0",
]

[[package]]
name = "regex"
version = "1.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c117dbdfde9c8308975b6a18d71f3f385c89461f7b3fb054288ecf2a2058ba4c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b83b8b9847f9bf95ef68afb0b8e6cdb80f498442f5179a29fad448fcc1eaea"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adad44e29e4c806119491a7f06f03de4d1af22c3a680dd47f1e6e179439d1f56"

[[package]]
name = "relative-path"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba39f3699c378cd8970968dcbff9c43159ea4cfbd88d43c00b22f2ef10a435d2"

[[package]]
name = "rstest"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d5316d2a1479eeef1ea21e7f9ddc67c191d497abc8fc3ba2467857abbb68330"
dependencies = [
 "futures",
 "futures-timer",
 "rstest_macros",
 "rustc_version",
]

[[package]]
name = "rstest_macros"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04a9df72cc1f67020b0d63ad9bfe4a323e459ea7eb68e03bd9824db49f9a4c25"
dependencies = [
 "cfg-if",
 "glob",
 "proc-macro2",
 "quote",
 "regex",
 "relative-path",
 "rustc_version",
 "syn 2.0.61",
 "unicode-ident",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc_version"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.37.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fea8ca367a3a01fe35e6943c400addf443c0f57670e6ec51196f71a4b8762dd2"
dependencies = [
 "bitflags 1.3.2",
 "errno",
 "io-lifetimes",
 "libc",
 "linux-raw-sys 0.3.8",
 "windows-sys 0.48.0",
]

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags 2.5.0",
 "errno",
 "libc",
 "linux-raw-sys 0.4.13",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustix-uring"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f180cb36639fbd3e5e12812e1e18d3b93ca05648e94bc8edc8d48bf5089cace"
dependencies = [
 "bitflags 2.5.0",
 "rustix 0.38.34",
]

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61697e0a1c7e512e84a621326239844a24d8207b4669b41bc18b32ea5cbf988b"

[[package]]
name = "serde"
version = "1.0.201"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "780f1cebed1629e4753a1a38a3c72d30b97ec044f0aef68cb26650a3c5cf363c"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.201"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5e405930b9796f1c00bee880d03fc7e0bb4b9a11afc776885ffe84320da2865"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.61",
]

[[package]]
name = "signal-hook"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8621587d4798caf8eb44879d42e56b9a93ea5dcd315a6487c357130095b62801"
dependencies = [
 "libc",
 "signal-hook-registry",
]

[[package]]
name = "signal-hook-mio"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29ad2e15f37ec9a6cc544097b78a1ec90001e9f71b81338ca39f430adaca99af"
dependencies = [
 "libc",
 "mio",
 "signal-hook",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "slice-group-by"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f7474f0b646d228360ab62ed974744617bc869d959eac8403bfa3665931a7fb"

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "smawk"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7c388c1b5e93756d0c740965c41e8822f866621d41acbdf6336a6a168f8840c"

[[package]]
name = "socket2"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "122e570113d28d773067fab24266b66753f6ea915758651696b6e35e49f88d6e"
dependencies = [
 "cfg-if",
 "libc",
 "winapi",
]

[[package]]
name = "socket2"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f7916fc008ca5542385b89a3d3ce689953c143e9304a9bf8beec1de48994c0d"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "supports-color"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9829b314621dfc575df4e409e79f9d6a66a3bd707ab73f23cb4aa3a854ac854f"
dependencies = [
 "is_ci",
]

[[package]]
name = "supports-hyperlinks"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c0a1e5168041f5f3ff68ff7d95dcb9c8749df29f6e7e89ada40dd4c9de404ee"

[[package]]
name = "supports-unicode"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7401a30af6cb5818bb64852270bb722533397edcfc7344954a38f420819ece2"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c993ed8ccba56ae856363b1845da7266a7cb78e1d146c8a32d54b45a8b831fc9"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85b77fafb263dd9d05cbeac119526425676db3784113aa9295c88498cbf8bff1"
dependencies = [
 "cfg-if",
 "fastrand 2.1.0",
 "rustix 0.38.34",
 "windows-sys 0.52.0",
]

[[package]]
name = "termbg"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c12e6e0bf9bc6ac887681aeddabfcc5dbdea20d3f43d6d18f237c34fe942dde"
dependencies = [
 "async-std",
 "crossterm",
 "is-terminal",
 "thiserror",
 "winapi",
]

[[package]]
name = "terminal-emoji"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8143568e8d5270b3b8f573ab8bb11a556a5c9e4becdc12241a7eef4c54a55170"
dependencies = [
 "terminal-supports-emoji",
]

[[package]]
name = "terminal-log-symbols"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7569386670bad024a2729d194542c42500615fca75f1139c99b697704f7e46f"
dependencies = [
 "ansi-colors-macro",
 "terminal-emoji",
]

[[package]]
name = "terminal-supports-emoji"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8873a7a1f2d286cfedc10663a722309b1c74092852cf149aee738cbe901c6eb"
dependencies = [
 "atty",
 "lazy_static",
]

[[package]]
name = "terminal_size"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21bebf2b7c9e0a515f6e0f8c51dc0f8e4696391e6f1ff30379559f8365fb0df7"
dependencies = [
 "rustix 0.38.34",
 "windows-sys 0.48.0",
]

[[package]]
name = "termtree"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3369f5ac52d5eb6ab48c6b4ffdc8efbcad6b89c765749064ba298f2c68a16a76"

[[package]]
name = "textwrap"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23d434d3f8967a09480fb04132ebe0a3e088c173e6d0ee7897abbdf4eab0f8b9"
dependencies = [
 "smawk",
 "unicode-linebreak",
 "unicode-width",
]

[[package]]
name = "thiserror"
version = "1.0.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "579e9083ca58dd9dcf91a9923bb9054071b9ebbd800b342194c9feb0ee89fc18"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2470041c06ec3ac1ab38d0356a6119054dedaea53e12fbefc0de730a1c08524"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.61",
]

[[package]]
name = "tokio"
version = "1.37.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1adbebffeca75fcfd058afa480fb6c0b81e165a0323f9c9d39c9697e37c46787"
dependencies = [
 "backtrace",
 "pin-project-lite",
]

[[package]]
name = "tracing"
version = "0.1.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
dependencies = [
 "pin-project-lite",
 "tracing-core",
]

[[package]]
name = "tracing-core"
version = "0.1.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"

[[package]]
name = "unicase"
version = "2.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7d2d4dafb69621809a81864c9c1b864479e1235c0dd4e199924b9742439ed89"
dependencies = [
 "version_check",
]

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-linebreak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b09c83c3c29d37506a3e260c08c03743a6bb66a9cd432c6934ab501a190571f"

[[package]]
name = "unicode-segmentation"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"

[[package]]
name = "unicode-width"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68f5e5f3158ecfd4b8ff6fe086db7c8467a2dfdac97fe420f2b7c4aa97af66d6"

[[package]]
name = "utf8parse"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "711b9620af191e0cdc7468a8d14e709c3dcdb115b36f838e601583af800a370a"

[[package]]
name = "value-bag"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a84c137d37ab0142f0f2ddfe332651fdbf252e7b7dbb4e67b6c1f1b2e925101"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "waker-fn"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "317211a0dc0ceedd78fb2ca9a44aed3d7b9b26f81870d485c07122b4350673b7"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4be2531df63900aeb2bca0daaaddec08491ee64ceecbee5076636a3b026795a8"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "614d787b966d3989fa7bb98a654e369c762374fd3213d212cfc0251257e747da"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.61",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76bc14366121efc8dbb487ab05bcc9d346b3b5ec0eaa76e46594cabbe51762c0"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.61",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af190c94f2773fdb3729c55b007a722abb5384da03bc0986df4c289bf5567e96"

[[package]]
name = "web-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77afa9a11836342370f4817622a2f0f418b134426d91a82dfb48f532d2ec13ef"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d4cc384e1e73b93bafa6fb4f1df8c41695c8a91cf9c4c64358067d15a7b6c6b"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.5",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f0713a46559409d202e70e28227288446bf7841d3211583a4b53e3f6d96e7eb"
dependencies = [
 "windows_aarch64_gnullvm 0.52.5",
 "windows_aarch64_msvc 0.52.5",
 "windows_i686_gnu 0.52.5",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.5",
 "windows_x86_64_gnu 0.52.5",
 "windows_x86_64_gnullvm 0.52.5",
 "windows_x86_64_msvc 0.52.5",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7088eed71e8b8dda258ecc8bac5fb1153c5cffaf2578fc8ff5d61e23578d3263"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9985fd1504e250c615ca5f281c3f7a6da76213ebd5ccc9561496568a2752afb6"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88ba073cf16d5372720ec942a8ccbf61626074c6d4dd2e745299726ce8b89670"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87f4261229030a858f36b459e748ae97545d6f1ec60e5e0d6a3d32e0dc232ee9"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db3c2bf3d13d5b658be73463284eaf12830ac9a26a90c717b7f771dfe97487bf"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e4246f76bdeff09eb48875a0fd3e2af6aada79d409d33011886d3e1581517d9"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "852298e482cd67c356ddd9570386e2862b5673c85bd5f88df9ab6802b334c596"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bec47e5bfd1bff0eeaf6d8b485cc1074891a197ab4225d504cb7a1ab88b02bf0"

[[package]]
name = "zerocopy"
version = "0.7.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae87e3fcd617500e5d106f0380cf7b77f3c6092aae37191433159dda23cfb087"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15e934569e47891f7d9411f1a451d947a60e000ab3bd24fbb970f000387d1b3b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.61",
]

</file>
<file path=./Cargo.toml>
[package]
name = "cunw"
description = "A tiny utility that generates a file representing the structure and content of a directory. Made to easily give context to a LLM."
license-file = "LICENSE"
repository = "https://github.com/RemiKalbe/cunw"
homepage = "https://github.com/RemiKalbe/cunw"
readme = "README.md"
keywords = ["code", "prompt", "directory", "context", "llm"]
categories = ["command-line-utilities", "filesystem"]
version = "0.1.0"
edition = "2021"

[dependencies]
arc-swap = "1.7.1"
clap = { version = "=4.5.3", features = ["derive", "unicode", "wrap_help"] }
clap-verbosity-flag = "2.2.0"
colored = "2.1.0"
env_logger = "0.11.3"
file-format = "0.25.0"
futures = "0.3.30"
globset = "0.4.14"
indicatif = { version = "0.17.8", features = ["improved_unicode"] }
log = "0.4.21"
miette = { version = "7.2.0", features = ["fancy"] }
nuclei = "0.4.4"
rstest = "0.19.0"
tempfile = "3.10.1"
termbg = "0.5.0"
terminal-emoji = "0.4.1"
terminal-log-symbols = "0.1.6"
termtree = "0.4.1"
thiserror = "1.0.60"
tokio = { version = "1.37.0", features = ["sync"] }
walkdir = "2.5.0"

</file>
<file path=./LICENSE>
Copyright 2024 Rémi Kalbe

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

</file>
<file path=./README.md>
# cunw

cunw (code unwrap) is a command-line interface (CLI) tool that generates a structured representation of a codebase, making it easy to provide context to a large language model (LLM). It recursively traverses a directory, collects file content, and generates a single Markdown file that represents the structure and content of the codebase.

> [!WARNING]
> Please note that cunw is currently in a very early and experimental stage. It has not been extensively tested and may be prone to crashes or unexpected behavior. However, rest assured that any crashes will be limited to the tool itself and will not cause any harm to your system or files.

## 🌟 Features

- Recursively traverses a directory and collects file content
- Generates a Markdown file representing the codebase structure and content
- Supports excluding and including files based on glob patterns
- Respects `.gitignore` files by default (can be disabled)
- Allows specifying the maximum depth of directory traversal
- Supports following symbolic links (disabled by default)

## 📦 Installation

### Precompiled Binaries

You can easily install cunw through cargo:

```bash
cargo install cunw
```

Or download the precompiled binaries from the [releases page](https://github.com/RemiKalbe/cunw/releases).

### From Source

To install cunw, ensure you have Rust and Cargo installed on your system. Then, clone the repository and build the project:

```bash
git clone https://github.com/RemiKalbe/cunw.git
cd cunw
cargo build --release
```

The compiled binary will be available at `target/release/cunw`.

## 🚀 Usage

```bash
cunw [OPTIONS]
```

### Options

- `-p, --path <PATH>`: The path to the directory containing the codebase. Default: `.`
- `-o, --output <FILE>`: The path of the output file. Default: `output.md`
- `-e, --exclude <PATTERN>`: Exclude files or directories matching the specified glob pattern.
- `-i, --include <PATTERN>`: Include only files or directories matching the specified glob pattern.
- `--do-not-consider-ignore-files`: Do not consider the ignore files (`.gitignore`, `.hgignore`, `.ignore`, `.git/info/exclude`, and `core.excludesFile` in `.git/config`). Default: `false`
- `--dangerously-allow-dot-git-traversal`: Include `.git` directory in the search. Default: `false`
- `-d, --max-depth <DEPTH>`: Maximum depth to walk into the directory tree.
- `-f, --follow-symbolic-links`: Follow symbolic links. Default: `false`
- `-v, --verbose`: Set the verbosity level. Can be used multiple times to increase verbosity.

### Example

To generate a Markdown representation of a codebase located at `path/to/codebase`, excluding files matching `*.txt` and including only files matching `src/**/*.rs`, and save the output to `codebase.md`:

```bash
cunw -p path/to/codebase -o codebase.md -e "*.txt" -i "src/**/*.rs"
```

## 📝 Output Format

The generated Markdown file will have the following structure:

```markdown
<directory_structure>
.
└─ .
├─ ./src
│ ├─ main.rs
│ └─ lib.rs
├─ .gitignore
├─ Cargo.lock
└─ Cargo.toml
</directory_structure>

<file path="Cargo.toml">
[package]
name = "cunw"
version = "0.1.0"
edition = "2021"

[dependencies]

<!-- ... -->
</file>

<file path="src/main.rs">
fn main() {
    println!("Hello, world!");
}
</file>

<!-- ... -->
```

The `<directory_structure>` section represents the directory tree of the codebase, and each `<file>` section contains the content of a specific file.

## 🤝 Contributing

Contributions are welcome! If you find any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.

## 📄 License

This project is licensed under the [MIT License](LICENSE).

</file>
<file path=./src/args.rs>
use std::path::PathBuf;

use clap::{builder::ValueHint, ArgAction, Parser};
use clap_verbosity_flag::{InfoLevel, Verbosity};
use globset::Glob;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
pub struct Args {
    #[arg(index = 1, short, long, help = "The path to the directory containing the codebase.", value_hint = ValueHint::DirPath, required = false, default_value = "")]
    pub path: PathBuf,
    #[arg(short, long, help = "The path of the output file.", value_hint = ValueHint::FilePath, required = false, default_value = "output.md")]
    pub output: Option<PathBuf>,
    #[arg(short, long, help = "Exclude files or directories matching the specified pattern.", value_hint = ValueHint::Other, required = false, num_args = 0.., action = ArgAction::Append)]
    pub exclude: Option<Vec<Glob>>,
    #[arg(
        long,
        help = "Do not consider the ignore files (.gitignore, .hgignore, .ignore, .git/info/exclude and core.excludesFile in .git/config).",
        required = false,
        default_value = "false"
    )]
    pub do_not_consider_ignore_files: bool,
    #[arg(
        long,
        help = "Include .git directory in the search.",
        required = false,
        default_value = "false"
    )]
    pub dangerously_allow_dot_git_traversal: bool,
    #[arg(short, long, help = "Maximum depth to walk into the directory tree.", value_hint = ValueHint::Other, required = false)]
    pub max_depth: Option<usize>,
    #[arg(
        short,
        long,
        help = "Follow symbolic links.",
        required = false,
        default_value = "false"
    )]
    pub follow_symbolic_links: bool,
    #[command(flatten)]
    pub verbosity: Verbosity<InfoLevel>,
}

</file>
<file path=./src/codebase.rs>
use futures::AsyncReadExt;
use miette::{IntoDiagnostic, Result, WrapErr};
use std::{
    fmt::{self, Display, Formatter},
    fs::File,
    path::{Path, PathBuf},
    sync::{Arc, Weak},
};
use tokio::sync::Mutex;

use arc_swap::ArcSwap;
use globset::GlobSet;
use nuclei::Task;
use termtree::Tree;
use walkdir::WalkDir;

use crate::{gitignore::GitIgnore, logger::Logger};

pub fn search_parent(path: PathBuf, root: &mut Tree<CodebaseItem>) -> &mut Tree<CodebaseItem> {
    Logger::trace(format!("Searching for parent of {} 👀", path.display()).as_str());
    if path.starts_with(&root.root.path()) {
        Logger::trace(format!("Found parent 🎉 {}", root.root.path().display()).as_str());

        return root;
    }

    for child in &mut root.leaves {
        let result = search_parent(path.clone(), child);
        if result.root == root.root {
            Logger::trace(format!("Found parent 🎉 {}", root.root.path().display()).as_str());

            return root;
        }
    }

    Logger::trace(format!("No parent found for {} 😢", path.display()).as_str());

    root
}

pub struct CodebaseBuilder {
    excluded_paths: Option<GlobSet>,
    consider_gitignores: Option<bool>,
    max_depth: Option<usize>,
    follow_symlinks: Option<bool>,
    skip_hidden_on_windows: Option<bool>,
}

impl CodebaseBuilder {
    pub fn new() -> Self {
        Self {
            excluded_paths: None,
            consider_gitignores: None,
            max_depth: None,
            follow_symlinks: None,
            skip_hidden_on_windows: None,
        }
    }

    pub fn excluded_paths(mut self, excluded_paths: GlobSet) -> Self {
        self.excluded_paths = Some(excluded_paths);
        self
    }

    pub fn consider_gitignores(mut self, consider_gitignores: bool) -> Self {
        self.consider_gitignores = Some(consider_gitignores);
        self
    }

    pub fn max_depth(mut self, max_depth: usize) -> Self {
        self.max_depth = Some(max_depth);
        self
    }

    pub fn follow_symlinks(mut self, follow_symlinks: bool) -> Self {
        self.follow_symlinks = Some(follow_symlinks);
        self
    }

    pub fn skip_hidden_on_windows(mut self, skip_hidden_on_windows: bool) -> Self {
        self.skip_hidden_on_windows = Some(skip_hidden_on_windows);
        self
    }

    pub fn build(self, from: PathBuf) -> Result<Codebase> {
        Logger::debug(format!("Building 🏗️ codebase from {}", from.display()).as_str());

        let root = CodebaseItem::Directory(Arc::new(CodebaseDir {
            path: from.clone(),
            parent: None,
        }));
        let mut tree = Tree::new(root);

        let mut walker = WalkDir::new(from).sort_by_file_name();
        if let Some(max_depth) = self.max_depth {
            walker = walker.max_depth(max_depth);
        }
        if let Some(follow_symlinks) = self.follow_symlinks {
            walker = walker.follow_links(follow_symlinks);
        }

        let mut it = walker.into_iter();
        // Keep track of the parents of the current branch.
        // This allows us to rewind once we reach a leaf.
        let mut current = &mut tree;
        let initial_gitignore = Arc::new(GitIgnore::from_dir(current.root.path())?);
        // This could be improved, here the Option is used to satisfy the compiler
        // but it is guaranteed to be Some.
        let mut gitignores: Vec<Arc<Option<GitIgnore>>> = Vec::new();
        if initial_gitignore.is_some() {
            gitignores.push(initial_gitignore.clone());
        }

        while let Some(entry) = it.next() {
            match entry {
                Ok(entry) => {
                    Logger::trace(format!("Processing entry {}", entry.path().display()).as_str());

                    // Skip hidden files and directories on Windows.
                    // The reason for only doing this on Windows is that the
                    // hidden attribute does not exist on Unix systems.
                    // And just checking for a dot prefix could lead to false positives.
                    // Usually, hidden fiels on windows are hidden for a reason.
                    // The 'dot' prefix on the other hand is used for things that
                    // are not necessarily hidden; like .gitignore, .github, etc.
                    #[cfg(windows)]
                    if self.skip_hidden_on_windows().unwrap_or(true) {
                        crate::os::is_hidden_dir_entry(&entry)?;
                    }

                    // Get the path of the entry
                    let path = entry.path().to_path_buf();

                    // Test if the path is a child of the current branch
                    if !path.starts_with(current.root.path()) {
                        Logger::trace("It is not a child of the current branch");

                        // If not, find the closest parent by traversing up the tree
                        // until we find a parent that is a prefix of the path
                        current = search_parent(path.clone(), &mut tree);
                    }

                    //
                    // Check if the current directory has a .gitignore file (if enabled)
                    //
                    // 1. Get the path of the parent of the current entry
                    let parent_path = current.root.path();

                    Logger::trace(format!("Parent path: {}", parent_path.display()).as_str());

                    // 2. Find the gitignore file that is a child of the parent of the current entry
                    let maybe_gitignore = {
                        if self.consider_gitignores.unwrap_or(false) {
                            match gitignores.iter().find(|gitignore| {
                                gitignore.as_ref().as_ref().map_or(false, |gitignore| {
                                    gitignore.path.parent() == Some(parent_path)
                                    // <-- Check if the gitignore is a child of the parent
                                })
                            }) {
                                None => {
                                    Logger::trace("No gitignore found in the current branch");

                                    // If no gitignore is found, let's first check if the current entry's parent has a gitignore
                                    let maybe_gitignore = GitIgnore::from_dir(parent_path)?;
                                    match maybe_gitignore {
                                        Some(gitignore) => {
                                            Logger::trace(
                                                format!(
                                                    "Found gitignore in {}",
                                                    parent_path.display()
                                                )
                                                .as_str(),
                                            );

                                            let gitignore = Arc::new(Some(gitignore));
                                            gitignores.push(gitignore.clone());
                                            gitignore
                                        }
                                        None => {
                                            Logger::trace(
                                                format!(
                                                    "No gitignore found in {}",
                                                    parent_path.display()
                                                )
                                                .as_str(),
                                            );

                                            // If no gitignore is found, rewind the gitignores until we find a gitignore
                                            // that is a child of the parent of the current entry
                                            let mut maybe_candidate_gitignore = gitignores.pop();
                                            while let Some(c) = maybe_candidate_gitignore.as_ref() {
                                                if let Some(uc) = c.as_ref() {
                                                    // ^-- This is guaranteed to be Some

                                                    Logger::trace(
                                                        format!(
                                                            "Checking if the rewinded gitignore is a child of the parent: {}",
                                                            uc.path.display()
                                                        )
                                                        .as_str(),
                                                    );

                                                    if uc.path.parent() == Some(parent_path) {
                                                        // ^-- Check if the gitignore is a child of the parent
                                                        // If a gitignore is found, push it back to the gitignores stack

                                                        Logger::trace(
                                                            "It is a child of the parent 🥰, using this gitignore"
                                                        );

                                                        let gitignore = c.clone();
                                                        gitignores.push(Arc::clone(&gitignore));
                                                        break;
                                                    }
                                                    // Pop the last gitignore and try again
                                                    maybe_candidate_gitignore = gitignores.pop();
                                                }
                                            }
                                            Logger::trace("No gitignore found in the current branch, using the initial gitignore (if any)");

                                            // If no gitignore is found, use the initial gitignore
                                            match maybe_candidate_gitignore {
                                                Some(gitignore) => gitignore,
                                                None => initial_gitignore.clone(),
                                            }
                                        }
                                    }
                                }
                                Some(gitignore) => gitignore.clone(),
                            }
                        } else {
                            Arc::new(None)
                        }
                    };

                    // Is the entry excluded by the gitignore?
                    if maybe_gitignore
                        .as_ref()
                        .as_ref()
                        .map_or(false, |gitignore| gitignore.is_excluded(&path))
                    {
                        Logger::debug("Entry is excluded by the gitignore");

                        // If it's a directory, skip it entirely
                        if entry.file_type().is_dir() {
                            Logger::debug("Skipping directory");

                            it.skip_current_dir();
                        }
                        continue;
                    }

                    // Is the entry excluded by the ignore patterns?
                    if let Some(excluded_paths) = &self.excluded_paths {
                        if excluded_paths.is_match(&path) {
                            Logger::debug("Entry is excluded by the ignore patterns");

                            // If it's a directory, skip it entirely
                            if entry.file_type().is_dir() {
                                Logger::debug("Skipping directory");

                                it.skip_current_dir();
                            }
                            continue;
                        }
                    }

                    // Create a new branch or leaf based on the metadata
                    if entry.file_type().is_dir() {
                        Logger::trace("Creating a new branch");

                        // Create a new branch
                        let new_branch = CodebaseItem::Directory(Arc::new(CodebaseDir {
                            path,
                            parent: Some(Arc::downgrade(&current.root.as_dir().unwrap())),
                        }));
                        let new_tree = Tree::new(new_branch);
                        // Add the new branch to the current branch
                        current.leaves.push(new_tree);
                        // Move the current branch to the new branch
                        current = current.leaves.last_mut().unwrap();
                    } else if entry.file_type().is_file() {
                        Logger::trace("Creating a new leaf");

                        let new_leaf = CodebaseItem::File(Arc::new(CodebaseFile::from_path(
                            path,
                            Arc::downgrade(&current.root.as_dir().unwrap()),
                        )));
                        // Add the new leaf to the current branch
                        current.leaves.push(Tree::new(new_leaf));
                    }
                }
                Err(err) => {
                    Logger::error(format!("Error while reading entry: {:#?}", err).as_str());
                }
            }
        }

        Ok(Codebase { tree })
    }
}

#[derive(Debug)]
pub struct CodebaseDir {
    pub parent: Option<Weak<CodebaseDir>>,
    pub path: PathBuf,
}

impl PartialEq for CodebaseDir {
    fn eq(&self, other: &Self) -> bool {
        self.path == other.path
    }
}

impl Display for CodebaseDir {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // As this will be used to write the tree, we only
        // need to display the directory name (with a trailing slash)
        let name = self.path.file_name().unwrap_or_default().to_string_lossy();
        write!(f, "{}/", name)
    }
}

#[derive(Debug)]
pub struct FileContent {
    task: Arc<Mutex<Option<Task<Result<String>>>>>,
    content: ArcSwap<Option<String>>,
}

impl FileContent {
    pub fn from_path(path: PathBuf) -> Self {
        let task = nuclei::spawn(async move {
            let fo = File::open(&path)
                .expect(format!("Failed to open file: {}", path.display()).as_str());

            let mut file = nuclei::Handle::<File>::new(fo)
                .expect(format!("Failed to create file handle: {}", path.display()).as_str());
            let mut buffer = String::new();

            file.read_to_string(&mut buffer)
                .await
                .into_diagnostic()
                .wrap_err(format!("Failed to read file 😬: {}", path.display()))?;

            Ok(buffer)
        });
        let content = Arc::new(None);

        Self {
            task: Arc::new(Mutex::new(Some(task))),
            content: ArcSwap::new(content),
        }
    }
    pub async fn content(&self) -> Result<String> {
        let mut task = self.task.lock().await;
        let task = task.take().expect("Task is already taken 🤨, I messed up.");
        let content = task.await?;
        self.content.store(Arc::new(Some(content.clone())));
        Ok(content)
    }
}

#[derive(Debug)]
pub struct CodebaseFile {
    pub parent: Weak<CodebaseDir>,
    pub path: PathBuf,
    pub content: FileContent,
}

impl PartialEq for CodebaseFile {
    fn eq(&self, other: &Self) -> bool {
        self.path == other.path
    }
}

impl CodebaseFile {
    pub fn from_path(path: PathBuf, parent: Weak<CodebaseDir>) -> Self {
        let content = FileContent::from_path(path.clone());

        Self {
            parent,
            path,
            content,
        }
    }
    pub async fn content(&self) -> Result<String> {
        self.content.content().await
    }
}

impl Display for CodebaseFile {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // As this will be used to write the tree, we only
        // need to display the file name
        write!(f, "{}", self.path.file_name().unwrap().to_string_lossy())
    }
}

#[derive(Debug)]
pub enum CodebaseItem {
    File(Arc<CodebaseFile>),
    Directory(Arc<CodebaseDir>),
}

impl CodebaseItem {
    pub fn path(&self) -> &Path {
        match self {
            CodebaseItem::File(file) => file.path.as_path(),
            CodebaseItem::Directory(dir) => dir.path.as_path(),
        }
    }
    pub fn parent(&self) -> Option<Arc<CodebaseDir>> {
        match self {
            CodebaseItem::File(file) => file.parent.upgrade(),
            CodebaseItem::Directory(dir) => {
                if let Some(parent) = dir.parent.as_ref() {
                    parent.upgrade()
                } else {
                    None
                }
            }
        }
    }
    pub fn as_dir(&self) -> Option<Arc<CodebaseDir>> {
        match self {
            CodebaseItem::File(_) => None,
            CodebaseItem::Directory(dir) => Some(dir.clone()),
        }
    }
}

impl PartialEq for CodebaseItem {
    fn eq(&self, other: &Self) -> bool {
        self.path() == other.path()
    }
}

impl Display for CodebaseItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            CodebaseItem::File(file) => write!(f, "{}", file),
            CodebaseItem::Directory(dir) => write!(f, "{}", dir),
        }
    }
}

#[derive(Debug)]
pub struct Codebase {
    tree: Tree<CodebaseItem>,
}

impl Codebase {
    pub fn new(tree: Tree<CodebaseItem>) -> Self {
        Self { tree }
    }
    pub fn get_formated_tree(&self) -> String {
        format!("<directory_tree>\n{}\n</directory_tree>", self.tree)
    }
    fn get_formated_leaves_representation(
        tree: &Tree<CodebaseItem>,
        buffer: &mut String,
    ) -> Result<()> {
        let mut leaves = tree.leaves.iter();
        while let Some(leave) = leaves.next() {
            if let CodebaseItem::File(file) = &leave.root {
                let content = nuclei::block_on(async move { file.content().await })?;

                let formated_content = format!(
                    "<file path={}>\n{}\n</file>\n",
                    file.path.display(),
                    content
                );
                buffer.push_str(formated_content.as_str());
            }
            if let CodebaseItem::Directory(_) = &leave.root {
                Self::get_formated_leaves_representation(leave, buffer)?;
            }
        }
        Ok(())
    }
    pub fn get_formated_files_representation(&self) -> Result<String> {
        let mut buffer = String::new();
        Self::get_formated_leaves_representation(&self.tree, &mut buffer)?;
        Ok(buffer)
    }
}

</file>
<file path=./src/gitignore.rs>
use std::path::{Path, PathBuf};

use globset::{Glob, GlobSet};
use miette::{IntoDiagnostic, Result, WrapErr};

use crate::logger::Logger;

pub struct GitIgnore {
    pub path: PathBuf,
    excluded_paths: GlobSet,
    // Note that includes take precedence over excludes
    included_paths: GlobSet,
}

impl GitIgnore {
    /// Constructs a new `GitIgnore` from a given directory.
    ///
    /// This function looks for a .gitignore file in the given directory and constructs
    /// a new `GitIgnore` instance that can be used to check if paths are excluded or not.
    ///
    /// # Arguments
    ///
    /// * `dir` - A `Path` representing the directory to search for a .gitignore file.
    ///
    /// # Returns
    ///
    /// A new `GitIgnore` instance if a .gitignore file is found in the directory, otherwise `None`.
    pub fn from_dir(dir: &Path) -> Result<Option<Self>> {
        Logger::debug(format!("Checking 🕵️‍♂️ for .gitignore file in directory: {:?}", dir).as_str());

        let gitignore_path = dir.join(".gitignore");
        if gitignore_path.exists() {
            Ok(Some(Self::from_path(gitignore_path)?))
        } else {
            Ok(None)
        }
    }

    /// Fix weird behavior with patterns that start with `/` or `.`
    fn maybe_pattern_to_variants(pattern: &str) -> Vec<String> {
        let mut variants = Vec::new();
        if pattern.starts_with("/") {
            variants.push(format!(".{}", pattern));
        }
        if pattern.starts_with(".") {
            variants.push(format!("./{}", pattern));
        }
        variants.push(pattern.to_string());
        variants
    }

    /// Constructs a new `GitIgnore` from a given .gitignore file path.
    ///
    /// This function reads the .gitignore file specified by the `path` and constructs
    /// a new `GitIgnore` instance that can be used to check if paths are excluded or not.
    ///
    /// # Arguments
    ///
    /// * `path` - A `PathBuf` representing the path to the .gitignore file.
    ///
    /// # Panics
    ///
    /// This function panics if the .gitignore file cannot be read or if it fails to
    /// build the glob sets. Glob patterns that are invalid will be logged as errors
    /// and skipped.
    pub fn from_path(path: PathBuf) -> Result<Self> {
        Logger::debug(format!("Reading 📖 .gitignore file at path: {:?}", path).as_str());

        let file = std::fs::read_to_string(&path).into_diagnostic()
            .wrap_err(format!(
                "Failed to read .gitignore at path: {:?} 😢. It may not be a valid UTF-8 file, or I messed up somewhere 🫢.",
                path
            ))?;

        let mut excluded_paths = GlobSet::builder();
        let mut included_paths = GlobSet::builder();
        for line in file.lines() {
            Logger::trace(format!("Parsing line in .gitignore: {:?}", line).as_str());

            if line.starts_with("#") {
                Logger::trace("Skipping line because it is a comment");

                continue;
            }
            if line.starts_with("!") {
                Logger::trace("Starting with !, parsing as included pattern");

                let included_pattern = line.trim_start_matches('!');
                let variants = Self::maybe_pattern_to_variants(included_pattern);
                for variant in variants {
                    let included_glob = Glob::new(&variant).into_diagnostic()
                        .wrap_err(format!(
                            "Failed to parse include pattern in .gitignore at {:?} 😢. The pattern {:?} will be ignored 🙅‍♀️.",
                            path, line
                        ));
                    match included_glob {
                        Ok(g) => {
                            included_paths.add(g);
                        }
                        Err(e) => {
                            Logger::error(e.to_string().as_str());
                        }
                    }
                }
            } else {
                Logger::trace("Parsing as excluded pattern");

                let variants = Self::maybe_pattern_to_variants(line);
                for variant in variants {
                    let excluded_glob = Glob::new(&variant).into_diagnostic()
                        .wrap_err(format!(
                            "Failed to parse exclude pattern in .gitignore at {:?} 😢. The pattern {:?} will be ignored 🙅‍♀️.",
                            path, line
                        ));
                    match excluded_glob {
                        Ok(g) => {
                            excluded_paths.add(g);
                        }
                        Err(e) => {
                            Logger::error(e.to_string().as_str());
                        }
                    }
                }
            }
        }
        Logger::trace("Finished parsing .gitignore file");

        Logger::debug("Building glob sets for excluded and included paths");

        let excluded_paths = excluded_paths.build().into_diagnostic().wrap_err(format!(
            "Failed to build glob set for excluded paths from .gitignore at path: {:?} 😢.",
            path
        ))?;
        let included_paths = included_paths.build().into_diagnostic().wrap_err(format!(
            "Failed to build glob set for included paths from .gitignore at path: {:?} 😢.",
            path
        ))?;

        Logger::debug("Finished building glob sets for excluded and included paths");

        Ok(Self {
            path,
            excluded_paths,
            included_paths,
        })
    }

    /// Determines if a given path is excluded by the .gitignore rules.
    ///
    /// This method checks if the specified `path` matches any of the exclude patterns
    /// and does not match any of the include patterns in the .gitignore file.
    ///
    /// # Arguments
    ///
    /// * `path` - A reference to a `Path` that will be checked against the .gitignore rules.
    ///
    /// # Returns
    ///
    /// Returns `true` if the path is excluded by the .gitignore rules, otherwise `false`.
    pub fn is_excluded(&self, path: &Path) -> bool {
        let t = self.excluded_paths.is_match(path) && !self.included_paths.is_match(path);
        Logger::trace(
            format!(
                "Checked if path {:?} is excluded in this .gitignore: {}",
                path, t
            )
            .as_str(),
        );
        t
    }
}

</file>
<file path=./src/logger.rs>
use std::panic::Location;

use colored::{ColoredString, Colorize};
use log::{debug, error, info, trace, warn, Level};
use terminal_emoji::Emoji;

pub struct Logger;

pub const LOCATION_WIDTH: usize = 35;
pub const LEVEL_WIDTH: usize = 3;

impl Logger {
    fn format_location(l: &Location<'static>) -> ColoredString {
        let file = l.file();
        let line = l.line();
        let column = l.column();
        let l = format!("in {} {}:{}", file.underline(), line, column);
        let padding = " ".repeat(LOCATION_WIDTH - l.chars().count());
        format!("{}{}", l, padding).dimmed()
    }
    fn format_level(level: Level) -> ColoredString {
        let padding = " ".repeat(LEVEL_WIDTH - 1);
        match level {
            Level::Error => format!("{}{}", Emoji::new("🚨", "E"), padding).red(),
            Level::Warn => format!("{}{}", Emoji::new("😳", "W"), padding).yellow(),
            Level::Info => format!("{}{}", Emoji::new("🤓", "I"), padding).green(),
            Level::Debug => format!("{}{}", Emoji::new("🐛", "D"), padding).blue(),
            Level::Trace => format!("{}{}", Emoji::new("🔬", "T"), padding).purple(),
        }
    }
    #[track_caller]
    pub fn trace(message: &str) {
        let location = Location::caller();
        trace!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Trace),
            message.purple(),
        );
    }
    #[track_caller]
    pub fn debug(message: &str) {
        let location = Location::caller();
        debug!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Debug),
            message.blue(),
        );
    }
    #[track_caller]
    pub fn info(message: &str) {
        let location = Location::caller();
        info!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Info),
            message.green(),
        );
    }
    #[track_caller]
    pub fn warn(message: &str) {
        let location = Location::caller();
        warn!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Warn),
            message.yellow(),
        );
    }
    #[track_caller]
    pub fn error(message: &str) {
        let location = Location::caller();
        error!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Error),
            message.red(),
        );
    }
}

</file>
<file path=./src/main.rs>
use clap::Parser;
use globset::{Glob, GlobSetBuilder};
use indicatif::ProgressBar;
use miette::{Context, IntoDiagnostic, Result};

pub mod args;
pub mod codebase;
//pub mod file;
pub mod gitignore;
pub mod logger;
pub mod os;
//pub mod walk;

use codebase::CodebaseBuilder;
use logger::Logger;

/// Git related globs to ignore, I don't see a reason
/// why we should consider these files but if you want
/// to include them you can use `--dangerously-allow-dot-git-traversal` flag.
const GIT_RELATED_IGNORE_PATTERNS: [&str; 6] = [
    ".git",
    "./.git",
    ".git/*",
    "./.git/*",
    ".git/**",
    "./.git/**",
];

const CRATE_NAME: &str = env!("CARGO_PKG_NAME");

#[nuclei::main]
async fn main() -> Result<()> {
    // Record the start time of the program
    // This is used to calculate the total time taken by the program
    let start = std::time::Instant::now();

    // Parse the command line arguments
    let args = args::Args::parse();

    // Set the log level based on the verbosity flag
    env_logger::builder()
        .format_timestamp(None)
        .format_level(false)
        .format_target(false)
        .format_module_path(false)
        .format_indent(Some(logger::LEVEL_WIDTH + logger::LOCATION_WIDTH))
        .filter_module(CRATE_NAME, args.verbosity.log_level_filter())
        .init();

    // Build the excluded paths
    let mut excluded_paths = GlobSetBuilder::new();
    if let Some(exclude) = args.exclude {
        for glob in exclude {
            excluded_paths.add(glob);
        }
    }
    if !args.do_not_consider_ignore_files {
        for pattern in GIT_RELATED_IGNORE_PATTERNS.iter() {
            excluded_paths.add(Glob::new(pattern).unwrap());
        }
    }
    let excluded_paths = excluded_paths.build().unwrap();

    // Build Codebase
    let codebase = CodebaseBuilder::new()
        .excluded_paths(excluded_paths)
        .consider_gitignores(!args.do_not_consider_ignore_files)
        .max_depth(args.max_depth.unwrap_or(std::usize::MAX))
        .follow_symlinks(args.follow_symbolic_links)
        .build(args.path)?;

    // Create and write to output file
    let formated_tree = codebase.get_formated_tree();
    let formated_files_representation = codebase.get_formated_files_representation()?;
    let mut output_str = String::new();
    output_str.push_str(&formated_tree);
    output_str.push_str("\n\n");
    output_str.push_str(&formated_files_representation);

    let output = args
        .output
        .unwrap_or(std::path::PathBuf::from("output.txt"));
    std::fs::write(output, output_str)
        .into_diagnostic()
        .wrap_err("Failed to write to output file 🫥")?;

    // Record the end time of the program
    let end = std::time::Instant::now();
    // Calculate the time taken by the program
    let time_taken = end - start;
    let time_taken = time_taken.as_secs_f64();
    // Print the time taken by the program
    Logger::info(format!("Done in: {:.4} seconds\r\n", time_taken).as_str());

    Ok(())
}

</file>
<file path=./src/os.rs>
use miette::Result;
use walkdir::DirEntry;

// Windows-specific constant used to check if a file is hidden.
const FILE_ATTRIBUTE_HIDDEN: u32 = 0x00000002;

#[cfg(windows)]
pub fn is_hidden_dir_entry(file: &DirEntry) -> Result<bool> {
    Ok(file.metadata()?.file_attributes() & FILE_ATTRIBUTE_HIDDEN != 0)
}

</file>

</file>
<file path=./src/args.rs>
use std::path::PathBuf;

use clap::{builder::ValueHint, ArgAction, Parser};
use clap_verbosity_flag::{InfoLevel, Verbosity};
use globset::Glob;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
pub struct Args {
    #[arg(index = 1, short, long, help = "The path to the directory containing the codebase.", value_hint = ValueHint::DirPath, required = true)]
    pub path: PathBuf,
    #[arg(short, long, help = "The path of the output file.", value_hint = ValueHint::FilePath, required = false, default_value = "output.txt")]
    pub output: Option<PathBuf>,
    #[arg(short, long, help = "Exclude files or directories matching the specified pattern.", value_hint = ValueHint::Other, required = false, num_args = 0.., action = ArgAction::Append)]
    pub exclude: Option<Vec<Glob>>,
    #[arg(
        long,
        help = "Do not consider the ignore files (.gitignore, .hgignore, .ignore, .git/info/exclude and core.excludesFile in .git/config).",
        required = false,
        default_value = "false"
    )]
    pub do_not_consider_ignore_files: bool,
    #[arg(
        long,
        help = "Include .git directory in the search.",
        required = false,
        default_value = "false"
    )]
    pub dangerously_allow_dot_git_traversal: bool,
    #[arg(short, long, help = "Maximum depth to walk into the directory tree.", value_hint = ValueHint::Other, required = false)]
    pub max_depth: Option<usize>,
    #[arg(
        short,
        long,
        help = "Follow symbolic links.",
        required = false,
        default_value = "false"
    )]
    pub follow_symbolic_links: bool,
    #[command(flatten)]
    pub verbosity: Verbosity<InfoLevel>,
}

</file>
<file path=./src/codebase.rs>
use futures::AsyncReadExt;
use miette::{IntoDiagnostic, Result, WrapErr};
use std::{
    fmt::{self, Display, Formatter},
    fs::File,
    path::{Path, PathBuf},
    sync::{Arc, Weak},
};
use tokio::sync::Mutex;

use arc_swap::ArcSwap;
use globset::GlobSet;
use nuclei::Task;
use termtree::Tree;
use walkdir::WalkDir;

use crate::{gitignore::GitIgnore, logger::Logger};

pub fn search_parent(path: PathBuf, root: &mut Tree<CodebaseItem>) -> &mut Tree<CodebaseItem> {
    Logger::trace(format!("Searching for parent of {} 👀", path.display()).as_str());
    if path.starts_with(&root.root.path()) {
        Logger::trace(format!("Found parent 🎉 {}", root.root.path().display()).as_str());

        return root;
    }

    for child in &mut root.leaves {
        let result = search_parent(path.clone(), child);
        if result.root == root.root {
            Logger::trace(format!("Found parent 🎉 {}", root.root.path().display()).as_str());

            return root;
        }
    }

    Logger::trace(format!("No parent found for {} 😢", path.display()).as_str());

    root
}

pub struct CodebaseBuilder {
    excluded_paths: Option<GlobSet>,
    consider_gitignores: Option<bool>,
    max_depth: Option<usize>,
    follow_symlinks: Option<bool>,
    skip_hidden_on_windows: Option<bool>,
}

impl CodebaseBuilder {
    pub fn new() -> Self {
        Self {
            excluded_paths: None,
            consider_gitignores: None,
            max_depth: None,
            follow_symlinks: None,
            skip_hidden_on_windows: None,
        }
    }

    pub fn excluded_paths(mut self, excluded_paths: GlobSet) -> Self {
        self.excluded_paths = Some(excluded_paths);
        self
    }

    pub fn consider_gitignores(mut self, consider_gitignores: bool) -> Self {
        self.consider_gitignores = Some(consider_gitignores);
        self
    }

    pub fn max_depth(mut self, max_depth: usize) -> Self {
        self.max_depth = Some(max_depth);
        self
    }

    pub fn follow_symlinks(mut self, follow_symlinks: bool) -> Self {
        self.follow_symlinks = Some(follow_symlinks);
        self
    }

    pub fn skip_hidden_on_windows(mut self, skip_hidden_on_windows: bool) -> Self {
        self.skip_hidden_on_windows = Some(skip_hidden_on_windows);
        self
    }

    pub fn build(self, from: PathBuf) -> Result<Codebase> {
        Logger::debug(format!("Building 🏗️ codebase from {}", from.display()).as_str());

        let root = CodebaseItem::Directory(Arc::new(CodebaseDir {
            path: from.clone(),
            parent: None,
        }));
        let mut tree = Tree::new(root);

        let mut walker = WalkDir::new(from).sort_by_file_name();
        if let Some(max_depth) = self.max_depth {
            walker = walker.max_depth(max_depth);
        }
        if let Some(follow_symlinks) = self.follow_symlinks {
            walker = walker.follow_links(follow_symlinks);
        }

        let mut it = walker.into_iter();
        // Keep track of the parents of the current branch.
        // This allows us to rewind once we reach a leaf.
        let mut current = &mut tree;
        let initial_gitignore = Arc::new(GitIgnore::from_dir(current.root.path())?);
        // This could be improved, here the Option is used to satisfy the compiler
        // but it is guaranteed to be Some.
        let mut gitignores: Vec<Arc<Option<GitIgnore>>> = Vec::new();
        if initial_gitignore.is_some() {
            gitignores.push(initial_gitignore.clone());
        }

        while let Some(entry) = it.next() {
            match entry {
                Ok(entry) => {
                    Logger::trace(format!("Processing entry {}", entry.path().display()).as_str());

                    // Skip hidden files and directories on Windows.
                    // The reason for only doing this on Windows is that the
                    // hidden attribute does not exist on Unix systems.
                    // And just checking for a dot prefix could lead to false positives.
                    // Usually, hidden fiels on windows are hidden for a reason.
                    // The 'dot' prefix on the other hand is used for things that
                    // are not necessarily hidden; like .gitignore, .github, etc.
                    #[cfg(windows)]
                    if self.skip_hidden_on_windows().unwrap_or(true) {
                        crate::os::is_hidden_dir_entry(&entry)?;
                    }

                    // Get the path of the entry
                    let path = entry.path().to_path_buf();

                    // Test if the path is a child of the current branch
                    if !path.starts_with(current.root.path()) {
                        Logger::trace("It is not a child of the current branch");

                        // If not, find the closest parent by traversing up the tree
                        // until we find a parent that is a prefix of the path
                        current = search_parent(path.clone(), &mut tree);
                    }

                    //
                    // Check if the current directory has a .gitignore file (if enabled)
                    //
                    // 1. Get the path of the parent of the current entry
                    let parent_path = current.root.path();

                    Logger::trace(format!("Parent path: {}", parent_path.display()).as_str());

                    // 2. Find the gitignore file that is a child of the parent of the current entry
                    let maybe_gitignore = {
                        if self.consider_gitignores.unwrap_or(false) {
                            match gitignores.iter().find(|gitignore| {
                                gitignore.as_ref().as_ref().map_or(false, |gitignore| {
                                    gitignore.path.parent() == Some(parent_path)
                                    // <-- Check if the gitignore is a child of the parent
                                })
                            }) {
                                None => {
                                    Logger::trace("No gitignore found in the current branch");

                                    // If no gitignore is found, let's first check if the current entry's parent has a gitignore
                                    let maybe_gitignore = GitIgnore::from_dir(parent_path)?;
                                    match maybe_gitignore {
                                        Some(gitignore) => {
                                            Logger::trace(
                                                format!(
                                                    "Found gitignore in {}",
                                                    parent_path.display()
                                                )
                                                .as_str(),
                                            );

                                            let gitignore = Arc::new(Some(gitignore));
                                            gitignores.push(gitignore.clone());
                                            gitignore
                                        }
                                        None => {
                                            Logger::trace(
                                                format!(
                                                    "No gitignore found in {}",
                                                    parent_path.display()
                                                )
                                                .as_str(),
                                            );

                                            // If no gitignore is found, rewind the gitignores until we find a gitignore
                                            // that is a child of the parent of the current entry
                                            let mut maybe_candidate_gitignore = gitignores.pop();
                                            while let Some(c) = maybe_candidate_gitignore.as_ref() {
                                                if let Some(uc) = c.as_ref() {
                                                    // ^-- This is guaranteed to be Some

                                                    Logger::trace(
                                                        format!(
                                                            "Checking if the rewinded gitignore is a child of the parent: {}",
                                                            uc.path.display()
                                                        )
                                                        .as_str(),
                                                    );

                                                    if uc.path.parent() == Some(parent_path) {
                                                        // ^-- Check if the gitignore is a child of the parent
                                                        // If a gitignore is found, push it back to the gitignores stack

                                                        Logger::trace(
                                                            "It is a child of the parent 🥰, using this gitignore"
                                                        );

                                                        let gitignore = c.clone();
                                                        gitignores.push(Arc::clone(&gitignore));
                                                        break;
                                                    }
                                                    // Pop the last gitignore and try again
                                                    maybe_candidate_gitignore = gitignores.pop();
                                                }
                                            }
                                            Logger::trace("No gitignore found in the current branch, using the initial gitignore (if any)");

                                            // If no gitignore is found, use the initial gitignore
                                            match maybe_candidate_gitignore {
                                                Some(gitignore) => gitignore,
                                                None => initial_gitignore.clone(),
                                            }
                                        }
                                    }
                                }
                                Some(gitignore) => gitignore.clone(),
                            }
                        } else {
                            Arc::new(None)
                        }
                    };

                    // Is the entry excluded by the gitignore?
                    if maybe_gitignore
                        .as_ref()
                        .as_ref()
                        .map_or(false, |gitignore| gitignore.is_excluded(&path))
                    {
                        Logger::debug("Entry is excluded by the gitignore");

                        // If it's a directory, skip it entirely
                        if entry.file_type().is_dir() {
                            Logger::debug("Skipping directory");

                            it.skip_current_dir();
                        }
                        continue;
                    }

                    // Is the entry excluded by the ignore patterns?
                    if let Some(excluded_paths) = &self.excluded_paths {
                        if excluded_paths.is_match(&path) {
                            Logger::debug("Entry is excluded by the ignore patterns");

                            // If it's a directory, skip it entirely
                            if entry.file_type().is_dir() {
                                Logger::debug("Skipping directory");

                                it.skip_current_dir();
                            }
                            continue;
                        }
                    }

                    // Create a new branch or leaf based on the metadata
                    if entry.file_type().is_dir() {
                        Logger::trace("Creating a new branch");

                        // Create a new branch
                        let new_branch = CodebaseItem::Directory(Arc::new(CodebaseDir {
                            path,
                            parent: Some(Arc::downgrade(&current.root.as_dir().unwrap())),
                        }));
                        let new_tree = Tree::new(new_branch);
                        // Add the new branch to the current branch
                        current.leaves.push(new_tree);
                        // Move the current branch to the new branch
                        current = current.leaves.last_mut().unwrap();
                    } else if entry.file_type().is_file() {
                        Logger::trace("Creating a new leaf");

                        let new_leaf = CodebaseItem::File(Arc::new(CodebaseFile::from_path(
                            path,
                            Arc::downgrade(&current.root.as_dir().unwrap()),
                        )));
                        // Add the new leaf to the current branch
                        current.leaves.push(Tree::new(new_leaf));
                    }
                }
                Err(err) => {
                    Logger::error(format!("Error while reading entry: {:#?}", err).as_str());
                }
            }
        }

        Ok(Codebase { tree })
    }
}

#[derive(Debug)]
pub struct CodebaseDir {
    pub parent: Option<Weak<CodebaseDir>>,
    pub path: PathBuf,
}

impl PartialEq for CodebaseDir {
    fn eq(&self, other: &Self) -> bool {
        self.path == other.path
    }
}

impl Display for CodebaseDir {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // As this will be used to write the tree, we only
        // need to display the directory name (with a trailing slash)
        let name = self.path.file_name().unwrap_or_default().to_string_lossy();
        write!(f, "{}/", name)
    }
}

#[derive(Debug)]
pub struct FileContent {
    task: Arc<Mutex<Option<Task<Result<String>>>>>,
    content: ArcSwap<Option<String>>,
}

impl FileContent {
    pub fn from_path(path: PathBuf) -> Self {
        let task = nuclei::spawn(async move {
            let fo = File::open(&path)
                .expect(format!("Failed to open file: {}", path.display()).as_str());

            let mut file = nuclei::Handle::<File>::new(fo)
                .expect(format!("Failed to create file handle: {}", path.display()).as_str());
            let mut buffer = String::new();

            file.read_to_string(&mut buffer)
                .await
                .into_diagnostic()
                .wrap_err(format!("Failed to read file 😬: {}", path.display()))?;

            Ok(buffer)
        });
        let content = Arc::new(None);

        Self {
            task: Arc::new(Mutex::new(Some(task))),
            content: ArcSwap::new(content),
        }
    }
    pub async fn content(&self) -> Result<String> {
        let mut task = self.task.lock().await;
        let task = task.take().expect("Task is already taken 🤨, I messed up.");
        let content = task.await?;
        self.content.store(Arc::new(Some(content.clone())));
        Ok(content)
    }
}

#[derive(Debug)]
pub struct CodebaseFile {
    pub parent: Weak<CodebaseDir>,
    pub path: PathBuf,
    pub content: FileContent,
}

impl PartialEq for CodebaseFile {
    fn eq(&self, other: &Self) -> bool {
        self.path == other.path
    }
}

impl CodebaseFile {
    pub fn from_path(path: PathBuf, parent: Weak<CodebaseDir>) -> Self {
        let content = FileContent::from_path(path.clone());

        Self {
            parent,
            path,
            content,
        }
    }
    pub async fn content(&self) -> Result<String> {
        self.content.content().await
    }
}

impl Display for CodebaseFile {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // As this will be used to write the tree, we only
        // need to display the file name
        write!(f, "{}", self.path.file_name().unwrap().to_string_lossy())
    }
}

#[derive(Debug)]
pub enum CodebaseItem {
    File(Arc<CodebaseFile>),
    Directory(Arc<CodebaseDir>),
}

impl CodebaseItem {
    pub fn path(&self) -> &Path {
        match self {
            CodebaseItem::File(file) => file.path.as_path(),
            CodebaseItem::Directory(dir) => dir.path.as_path(),
        }
    }
    pub fn parent(&self) -> Option<Arc<CodebaseDir>> {
        match self {
            CodebaseItem::File(file) => file.parent.upgrade(),
            CodebaseItem::Directory(dir) => {
                if let Some(parent) = dir.parent.as_ref() {
                    parent.upgrade()
                } else {
                    None
                }
            }
        }
    }
    pub fn as_dir(&self) -> Option<Arc<CodebaseDir>> {
        match self {
            CodebaseItem::File(_) => None,
            CodebaseItem::Directory(dir) => Some(dir.clone()),
        }
    }
}

impl PartialEq for CodebaseItem {
    fn eq(&self, other: &Self) -> bool {
        self.path() == other.path()
    }
}

impl Display for CodebaseItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            CodebaseItem::File(file) => write!(f, "{}", file),
            CodebaseItem::Directory(dir) => write!(f, "{}", dir),
        }
    }
}

#[derive(Debug)]
pub struct Codebase {
    tree: Tree<CodebaseItem>,
}

impl Codebase {
    pub fn new(tree: Tree<CodebaseItem>) -> Self {
        Self { tree }
    }
    pub fn get_formated_tree(&self) -> String {
        format!("<directory_tree>\n{}\n</directory_tree>", self.tree)
    }
    fn get_formated_leaves_representation(
        tree: &Tree<CodebaseItem>,
        buffer: &mut String,
    ) -> Result<()> {
        let mut leaves = tree.leaves.iter();
        while let Some(leave) = leaves.next() {
            if let CodebaseItem::File(file) = &leave.root {
                let content = nuclei::block_on(async move { file.content().await })?;

                let formated_content = format!(
                    "<file path=\"{}\">\n{}\n</file>\n",
                    file.path.display(),
                    content
                );
                buffer.push_str(formated_content.as_str());
            }
            if let CodebaseItem::Directory(_) = &leave.root {
                Self::get_formated_leaves_representation(leave, buffer)?;
            }
        }
        Ok(())
    }
    pub fn get_formated_files_representation(&self) -> Result<String> {
        let mut buffer = String::new();
        Self::get_formated_leaves_representation(&self.tree, &mut buffer)?;
        Ok(buffer)
    }
}

</file>
<file path=./src/gitignore.rs>
use std::path::{Path, PathBuf};

use globset::{Glob, GlobSet};
use miette::{IntoDiagnostic, Result, WrapErr};

use crate::logger::Logger;

pub struct GitIgnore {
    pub path: PathBuf,
    excluded_paths: GlobSet,
    // Note that includes take precedence over excludes
    included_paths: GlobSet,
}

impl GitIgnore {
    /// Constructs a new `GitIgnore` from a given directory.
    ///
    /// This function looks for a .gitignore file in the given directory and constructs
    /// a new `GitIgnore` instance that can be used to check if paths are excluded or not.
    ///
    /// # Arguments
    ///
    /// * `dir` - A `Path` representing the directory to search for a .gitignore file.
    ///
    /// # Returns
    ///
    /// A new `GitIgnore` instance if a .gitignore file is found in the directory, otherwise `None`.
    pub fn from_dir(dir: &Path) -> Result<Option<Self>> {
        Logger::debug(format!("Checking 🕵️‍♂️ for .gitignore file in directory: {:?}", dir).as_str());

        let gitignore_path = dir.join(".gitignore");
        if gitignore_path.exists() {
            Ok(Some(Self::from_path(gitignore_path)?))
        } else {
            Ok(None)
        }
    }

    /// Fix weird behavior with patterns that start with `/` or `.`
    fn maybe_pattern_to_variants(pattern: &str) -> Vec<String> {
        let mut variants = Vec::new();
        if pattern.starts_with("/") {
            variants.push(format!(".{}", pattern));
        }
        if pattern.starts_with(".") {
            variants.push(format!("./{}", pattern));
        }
        variants.push(pattern.to_string());
        variants
    }

    /// Constructs a new `GitIgnore` from a given .gitignore file path.
    ///
    /// This function reads the .gitignore file specified by the `path` and constructs
    /// a new `GitIgnore` instance that can be used to check if paths are excluded or not.
    ///
    /// # Arguments
    ///
    /// * `path` - A `PathBuf` representing the path to the .gitignore file.
    ///
    /// # Panics
    ///
    /// This function panics if the .gitignore file cannot be read or if it fails to
    /// build the glob sets. Glob patterns that are invalid will be logged as errors
    /// and skipped.
    pub fn from_path(path: PathBuf) -> Result<Self> {
        Logger::debug(format!("Reading 📖 .gitignore file at path: {:?}", path).as_str());

        let file = std::fs::read_to_string(&path).into_diagnostic()
            .wrap_err(format!(
                "Failed to read .gitignore at path: {:?} 😢. It may not be a valid UTF-8 file, or I messed up somewhere 🫢.",
                path
            ))?;

        let mut excluded_paths = GlobSet::builder();
        let mut included_paths = GlobSet::builder();
        for line in file.lines() {
            Logger::trace(format!("Parsing line in .gitignore: {:?}", line).as_str());

            if line.starts_with("#") {
                Logger::trace("Skipping line because it is a comment");

                continue;
            }
            if line.starts_with("!") {
                Logger::trace("Starting with !, parsing as included pattern");

                let included_pattern = line.trim_start_matches('!');
                let variants = Self::maybe_pattern_to_variants(included_pattern);
                for variant in variants {
                    let included_glob = Glob::new(&variant).into_diagnostic()
                        .wrap_err(format!(
                            "Failed to parse include pattern in .gitignore at {:?} 😢. The pattern {:?} will be ignored 🙅‍♀️.",
                            path, line
                        ));
                    match included_glob {
                        Ok(g) => {
                            included_paths.add(g);
                        }
                        Err(e) => {
                            Logger::error(e.to_string().as_str());
                        }
                    }
                }
            } else {
                Logger::trace("Parsing as excluded pattern");

                let variants = Self::maybe_pattern_to_variants(line);
                for variant in variants {
                    let excluded_glob = Glob::new(&variant).into_diagnostic()
                        .wrap_err(format!(
                            "Failed to parse exclude pattern in .gitignore at {:?} 😢. The pattern {:?} will be ignored 🙅‍♀️.",
                            path, line
                        ));
                    match excluded_glob {
                        Ok(g) => {
                            excluded_paths.add(g);
                        }
                        Err(e) => {
                            Logger::error(e.to_string().as_str());
                        }
                    }
                }
            }
        }
        Logger::trace("Finished parsing .gitignore file");

        Logger::debug("Building glob sets for excluded and included paths");

        let excluded_paths = excluded_paths.build().into_diagnostic().wrap_err(format!(
            "Failed to build glob set for excluded paths from .gitignore at path: {:?} 😢.",
            path
        ))?;
        let included_paths = included_paths.build().into_diagnostic().wrap_err(format!(
            "Failed to build glob set for included paths from .gitignore at path: {:?} 😢.",
            path
        ))?;

        Logger::debug("Finished building glob sets for excluded and included paths");

        Ok(Self {
            path,
            excluded_paths,
            included_paths,
        })
    }

    /// Determines if a given path is excluded by the .gitignore rules.
    ///
    /// This method checks if the specified `path` matches any of the exclude patterns
    /// and does not match any of the include patterns in the .gitignore file.
    ///
    /// # Arguments
    ///
    /// * `path` - A reference to a `Path` that will be checked against the .gitignore rules.
    ///
    /// # Returns
    ///
    /// Returns `true` if the path is excluded by the .gitignore rules, otherwise `false`.
    pub fn is_excluded(&self, path: &Path) -> bool {
        let t = self.excluded_paths.is_match(path) && !self.included_paths.is_match(path);
        Logger::trace(
            format!(
                "Checked if path {:?} is excluded in this .gitignore: {}",
                path, t
            )
            .as_str(),
        );
        t
    }
}

</file>
<file path=./src/logger.rs>
use std::panic::Location;

use colored::{ColoredString, Colorize};
use log::{debug, error, info, trace, warn, Level};
use terminal_emoji::Emoji;

pub struct Logger;

pub const LOCATION_WIDTH: usize = 35;
pub const LEVEL_WIDTH: usize = 3;

impl Logger {
    fn format_location(l: &Location<'static>) -> ColoredString {
        let file = l.file();
        let line = l.line();
        let column = l.column();
        let l = format!("in {} {}:{}", file.underline(), line, column);
        let padding = " ".repeat(LOCATION_WIDTH - l.chars().count());
        format!("{}{}", l, padding).dimmed()
    }
    fn format_level(level: Level) -> ColoredString {
        let padding = " ".repeat(LEVEL_WIDTH - 1);
        match level {
            Level::Error => format!("{}{}", Emoji::new("🚨", "E"), padding).red(),
            Level::Warn => format!("{}{}", Emoji::new("😳", "W"), padding).yellow(),
            Level::Info => format!("{}{}", Emoji::new("🤓", "I"), padding).green(),
            Level::Debug => format!("{}{}", Emoji::new("🐛", "D"), padding).blue(),
            Level::Trace => format!("{}{}", Emoji::new("🔬", "T"), padding).purple(),
        }
    }
    #[track_caller]
    pub fn trace(message: &str) {
        let location = Location::caller();
        trace!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Trace),
            message.purple(),
        );
    }
    #[track_caller]
    pub fn debug(message: &str) {
        let location = Location::caller();
        debug!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Debug),
            message.blue(),
        );
    }
    #[track_caller]
    pub fn info(message: &str) {
        let location = Location::caller();
        info!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Info),
            message.green(),
        );
    }
    #[track_caller]
    pub fn warn(message: &str) {
        let location = Location::caller();
        warn!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Warn),
            message.yellow(),
        );
    }
    #[track_caller]
    pub fn error(message: &str) {
        let location = Location::caller();
        error!(
            "{} {} {}",
            Self::format_location(&location),
            Self::format_level(Level::Error),
            message.red(),
        );
    }
}

</file>
<file path=./src/main.rs>
use clap::Parser;
use globset::{Glob, GlobSetBuilder};
use indicatif::ProgressBar;
use miette::{Context, IntoDiagnostic, Result};

pub mod args;
pub mod codebase;
pub mod gitignore;
pub mod logger;
pub mod os;

use codebase::CodebaseBuilder;
use logger::Logger;

/// Git related globs to ignore, I don't see a reason
/// why we should consider these files but if you want
/// to include them you can use `--dangerously-allow-dot-git-traversal` flag.
const GIT_RELATED_IGNORE_PATTERNS: [&str; 2] = ["**/.git", "./**/.git"];

const CRATE_NAME: &str = env!("CARGO_PKG_NAME");

#[nuclei::main]
async fn main() -> Result<()> {
    // Record the start time of the program
    // This is used to calculate the total time taken by the program
    let start = std::time::Instant::now();

    // Parse the command line arguments
    let args = args::Args::parse();

    // Set the log level based on the verbosity flag
    env_logger::builder()
        .format_timestamp(None)
        .format_level(false)
        .format_target(false)
        .format_module_path(false)
        .format_indent(Some(logger::LEVEL_WIDTH + logger::LOCATION_WIDTH))
        .filter_module(CRATE_NAME, args.verbosity.log_level_filter())
        .init();

    // Build the excluded paths
    let mut excluded_paths = GlobSetBuilder::new();
    if let Some(exclude) = args.exclude {
        for glob in exclude {
            excluded_paths.add(glob);
        }
    }
    if !args.do_not_consider_ignore_files {
        for pattern in GIT_RELATED_IGNORE_PATTERNS.iter() {
            excluded_paths.add(Glob::new(pattern).unwrap());
        }
    }
    let excluded_paths = excluded_paths.build().unwrap();

    // Build Codebase
    let codebase = CodebaseBuilder::new()
        .excluded_paths(excluded_paths)
        .consider_gitignores(!args.do_not_consider_ignore_files)
        .max_depth(args.max_depth.unwrap_or(std::usize::MAX))
        .follow_symlinks(args.follow_symbolic_links)
        .build(args.path)?;

    // Create and write to output file
    let formated_tree = codebase.get_formated_tree();
    let formated_files_representation = codebase.get_formated_files_representation()?;
    let mut output_str = String::new();
    output_str.push_str(&formated_tree);
    output_str.push_str("\n\n");
    output_str.push_str(&formated_files_representation);

    let output = args
        .output
        .unwrap_or(std::path::PathBuf::from("output.txt"));
    std::fs::write(output, output_str)
        .into_diagnostic()
        .wrap_err("Failed to write to output file 🫥")?;

    // Record the end time of the program
    let end = std::time::Instant::now();
    // Calculate the time taken by the program
    let time_taken = end - start;
    let time_taken = time_taken.as_secs_f64();
    // Print the time taken by the program
    Logger::info(format!("Done in: {:.4} seconds\r\n", time_taken).as_str());

    Ok(())
}

</file>
<file path=./src/os.rs>
use miette::Result;
use walkdir::DirEntry;

// Windows-specific constant used to check if a file is hidden.
const FILE_ATTRIBUTE_HIDDEN: u32 = 0x00000002;

#[cfg(windows)]
pub fn is_hidden_dir_entry(file: &DirEntry) -> Result<bool> {
    Ok(file.metadata()?.file_attributes() & FILE_ATTRIBUTE_HIDDEN != 0)
}

</file>
